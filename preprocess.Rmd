---
title: "Epic_preprocessing"
author: "lijunx"
date: "June 12, 2023"
output: html_document
---

```{r setup, include=FALSE}
library("minfi")
library("tidyverse")
library("ggplot2")
library("ggpubr")
library("data.table")
library("DelayedArray")
library("BiocParallel")
library("scales")
library("ComplexHeatmap")
library(pheatmap)
```



The EPIC array used is version2, which does not have full support from minfi yet. Hence supporting document of annotation was manually downloaded from Illumina "https://support.illumina.com/array/array_kits/infinium-methylationepic-beadchip-kit/downloads.html" (14th JUN 2023)
We will need to construct annotation manually
```{r construct manifest}
#load annotation
annotation <- fread("supporting/EPIC-8v2-0_A1.csv", header = T, skip ="IlmnID")

IlluminaHumanMethylationEPICv2 <- IlluminaMethylationManifest(TypeControl = DataFrame(annotation %>%
                                                                filter(is.na(Infinium_Design), !is.na(Name)) %>%
                                                                dplyr::select(Address = IlmnID, Type = Name, color = AddressA_ID, ExtendedType = AlleleA_ProbeSeq)) ,
                                                              TypeI = DataFrame(annotation %>%
                                                                filter(Infinium_Design_Type == "I", startsWith(Name, "cg")) %>%
                                                                dplyr::select(Name, AddressA = AddressA_ID, AddressB =AddressB_ID, Color = Color_Channel, NextBase = Next_Base, ProbeSeqA = AlleleA_ProbeSeq, ProbeSeqB = AlleleB_ProbeSeq, nCpG = Rep_Num)),
                                                              TypeII = DataFrame(annotation %>%
                                                                filter(Infinium_Design_Type == "II", startsWith(Name, "cg"))  %>%
                                                                dplyr::select(Name, AddressA = AddressA_ID, AddressB =AddressB_ID, Color = Color_Channel, NextBase = Next_Base, ProbeSeqA = AlleleA_ProbeSeq, ProbeSeqB = AlleleB_ProbeSeq, nCpG = Rep_Num)),
                                                              TypeSnpI = DataFrame(annotation %>%
                                                                filter(Infinium_Design_Type == "I", 
                                                                       startsWith(Name, "rs")) %>%
                                                                dplyr::select(Name, AddressA = AddressA_ID, 
                                                                              AddressB = AddressB_ID, 
                                                                              Color = Color_Channel, 
                                                                              NextBase = Next_Base, 
                                                                              ProbeSeqA = AlleleA_ProbeSeq, 
                                                                              ProbeSeqB = AlleleB_ProbeSeq, 
                                                                              nCpG = Rep_Num)),
                                                              TypeSnpII = DataFrame(annotation %>%
                                                                filter(Infinium_Design_Type == "II", 
                                                                       startsWith(Name, "rs")) %>%
                                                                dplyr::select(Name, AddressA = AddressA_ID, 
                                                                              AddressB = AddressB_ID, 
                                                                              Color = Color_Channel, 
                                                                              NextBase = Next_Base, 
                                                                              ProbeSeqA = AlleleA_ProbeSeq, 
                                                                              ProbeSeqB = AlleleB_ProbeSeq, 
                                                                              nCpG = Rep_Num)),
                                                              annotation = "IlluminaHumanMethylationEPICV2")
                                                              
```


```{r load file}
# loading epic array
raw_data_dir = "raw"
target = read.metharray.sheet(raw_data_dir)
RGset <- read.metharray.exp(targets= target, verbose = F, extended = F)

# annotation_rows<- c("CHR", "MAPINFO","Name", "SNP_MinorAlleleFrequency", "SNP_DISTANCE",  "Islands_Name", "Relation_to_Island", "UCSC_RefGene_Name", "UCSC_RefGene_Group", "Phantom4_Enhancers", "Phantom5_Enhancers", "DMR", "HMM_Island", "Regulatory_Feature_Name", "Regulatory_Feature_Group", "GencodeBasicV12_NAME","GencodeCompV12_Group","OpenChromatin_NAME","OpenChromatin_Evidence_Count", "TFBS_NAME", "TFBS_Evidence_Count")
annotation
annotation_rows <- c("Name","MAPINFO", "CHR", "UCSC_CpG_Islands_Name", "HMM_Island", "OpenChromatin_NAME", "Regulatory_Feature_Name","Regulatory_Feature_Group" , "GencodeV41_Name", "Phantom5_Enhancers", "Relation_to_UCSC_CpG_Island", "UCSC_RefGene_Name" )
```


```{r extract method for manual processing}
.highestType <- function(...) {
    dots <- list(...)
    types <- vapply(dots, DelayedArray::type, character(1L))
    vector <- do.call(c, lapply(types, vector))  # guaranteed to be atomic
    typeof(vector)
}

.NA_type <- function(type) {
    c(vector(type), NA)
}
setGeneric(
    ".preprocessRawMeth",
    function(Red, Green, locusNames, TypeI.Red, TypeI.Green, TypeII, ...)
        standardGeneric(".preprocessRawMeth"),
    signature = c("Red", "Green"))

# `...` are additional arguments passed to methods.
setGeneric(
    ".preprocessRawUnmeth",
    function(Red, Green, locusNames, TypeI.Red, TypeI.Green, TypeII, ...)
        standardGeneric(".preprocessRawUnmeth"),
    signature = c("Red", "Green"))

# `...` are additional arguments passed to methods.
setGeneric(
    ".preprocessRaw",
    function(Red, Green, locusNames, TypeI.Red, TypeI.Green, TypeII, ...)
        standardGeneric(".preprocessRaw"),
    signature = c("Red", "Green"))

setMethod(
    ".preprocessRawMeth",
    c("matrix", "matrix"),
    function(Red, Green, locusNames, TypeI.Red, TypeI.Green, TypeII) {
        # Set up output matrix with appropriate dimension and type
        type <- .highestType(Red, Green)
        M <- matrix(.NA_type(type),
                    nrow = length(locusNames),
                    ncol = ncol(Red),
                    dimnames = list(locusNames, colnames(Red)))

        # Fill output matrix
        M[TypeI.Red$Name, ] <- Red[TypeI.Red$AddressB, ]
        M[TypeI.Green$Name, ] <- Green[TypeI.Green$AddressB, ]
        M[TypeII$Name, ] <- Green[TypeII$AddressA, ]

        # Return output matrix
        M
    }
)

setMethod(
    ".preprocessRawUnmeth",
    c("matrix", "matrix"),
    function(Red, Green, locusNames, TypeI.Red, TypeI.Green, TypeII, ...) {
        # Set up output matrix with appropriate dimension and type
        type <- .highestType(Red, Green)
        U <- matrix(.NA_type(type),
                    nrow = length(locusNames),
                    ncol = ncol(Red),
                    dimnames = list(locusNames, colnames(Red)))

        # Fill output matrix
        U[TypeI.Red$Name, ] <- Red[TypeI.Red$AddressA, ]
        U[TypeI.Green$Name, ] <- Green[TypeI.Green$AddressA, ]
        U[TypeII$Name, ] <- Red[TypeII$AddressA, ]

        # Return output matrix
        U
    }
)

setMethod(
    ".preprocessRaw",
    c("matrix", "matrix"),
    function(Red, Green, locusNames, TypeI.Red, TypeI.Green, TypeII, ...) {
        list(
            M = .preprocessRawMeth(
                Red, Green, locusNames, TypeI.Red, TypeI.Green, TypeII),
            U = .preprocessRawUnmeth(
                Red, Green, locusNames, TypeI.Red, TypeI.Green, TypeII))
    }
)

blockMapplyWithRealization <- function(FUN, ..., MoreArgs = NULL, sinks = NULL,
                                       dots_grids = NULL, sinks_grids = NULL,
                                       BPREDO = list(), BPPARAM = bpparam()) {
    FUN <- match.fun(FUN)
    dots <- unname(list(...))
    # Check valid `sinks`
    stopifnot(is.null(sinks) || is.list(sinks))
    # Check conformable dots_grids and sinks_grids
    if (is.null(dots_grids)) {
        dots_grids <- replicate(length(dots), NULL)
    } else {
        stopifnot(is.list(dots_grids))
    }
    dots_grids <- mapply(
        FUN = DelayedArray:::normarg_grid,
        dots_grids,
        dots,
        SIMPLIFY = FALSE,
        USE.NAMES = FALSE)
    if (is.null(sinks_grids)) {
        sinks_grids <- replicate(length(sinks), NULL)
    } else {
        stopifnot(is.list(sinks_grids))
    }
    sinks_grids <- mapply(
        FUN = DelayedArray:::normarg_grid,
        sinks_grids,
        sinks,
        SIMPLIFY = FALSE,
        USE.NAMES = FALSE)
    grids_dims <- lapply(c(dots_grids, sinks_grids), dim)
    all_same_grids_dims <- all(
        vapply(X = grids_dims,
               FUN = function(dim) all(dim == grids_dims[[1L]]),
               FUN.VALUE = logical(1L)))
    if (!all_same_grids_dims) {
        stop("non-conformable 'dots_grids' and 'sinks_grids'")
    }
    stopifnot(length(dots) == length(dots_grids),
              length(sinks) == length(sinks_grids))

    # Loop over blocks of `dots` and write to `sinks`
    nblock <- length(dots_grids[[1]])
    bplapply(seq_len(nblock), function(b) {
        if (DelayedArray:::get_verbose_block_processing()) {
            message("Processing block ", b, "/", nblock, " ... ",
                    appendLF = FALSE)
        }
        input_viewports <- lapply(dots_grids, function(grid) grid[[b]])
        output_viewports <- lapply(sinks_grids, function(grid) grid[[b]])
        blocks <- mapply(
            FUN = function(x, grid, viewport) {
                block <- read_block(x, viewport)
                attr(block, "from_grid") <- grid
                attr(block, "block_id") <- b
                block
            },
            x = dots,
            grid = dots_grids,
            viewport = input_viewports,
            SIMPLIFY = FALSE,
            USE.NAMES = FALSE)
        block_ans <- do.call(FUN, c(blocks, MoreArgs))
        if (!is.list(block_ans)) {
            block_ans <- list(block_ans)
        }
        # NOTE: This is the only part different from blockMapply()
        if (!is.null(sinks)) {
            mapply(function(ans, sink, viewport) {
                write_block(sink, viewport, ans)
            }, ans = block_ans, sink = sinks, viewport = output_viewports,
            SIMPLIFY = FALSE, USE.NAMES = FALSE)
            block_ans <- NULL
        }
        if (DelayedArray:::get_verbose_block_processing()) {
            message("OK")
        }
        block_ans
    },
    BPREDO = ,
    BPPARAM = bpparam())
}
```

```{r manual preprocessing raw methylation array}
#control normalisation and background correction
Green <- getGreen(RGset)
Red <- getRed(RGset)

AT.controls <- getControlAddress(
            object = IlluminaHumanMethylationEPICv2,
            controlType = c("NORM_A", "NORM_T"))
CG.controls <- getControlAddress(
            object = IlluminaHumanMethylationEPICv2,
            controlType = c("NORM_C", "NORM_G"))

assay(RGset, "Green") <- Green
assay(RGset, "Red") <- Red


#manually load into methylset to access available mapping
TypeI.Red <- getProbeInfo(IlluminaHumanMethylationEPICv2, type = "I-Red")
TypeI.Green <- getProbeInfo(IlluminaHumanMethylationEPICv2, type = "I-Green")
TypeII <- getProbeInfo(IlluminaHumanMethylationEPICv2, type = "II")
locusNames <- getManifestInfo(IlluminaHumanMethylationEPICv2, "locusNames")
M_and_U <- .preprocessRaw(
        Red = Red,
        Green = Green,
        locusNames = locusNames,
        TypeI.Red = TypeI.Red,
        TypeI.Green = TypeI.Green,
        TypeII = TypeII)
M <- M_and_U[["M"]]
U <- M_and_U[["U"]]


RGset_raw <- MethylSet(
        Meth = M,
        Unmeth = U,
        colData = colData(RGset),
        annotation = annotation(RGset),
        metadata = metadata(RGset))

```
```{r manual preprocessing normalisation methylation array against control probes from bulk62}
Green.avg <- colMeans2(Green, rows = match(CG.controls, rownames(Green)))
Red.avg <- colMeans2(Red, rows = match(AT.controls, rownames(Red)))
ref <- (Green.avg + Red.avg)[1] / 2

NegControls <- getControlAddress(IlluminaHumanMethylationEPICv2, controlType = "NEGATIVE")
Green.bg <- apply(Green[NegControls, , drop = FALSE], 2, function(xx) {
        sort(as.vector(xx))[31]})
Red.bg <- apply(Red[NegControls, , drop = FALSE], 2, function(xx) {
        sort(as.vector(xx))[31] })
Green <- pmax2(sweep(Green, 2, Green.bg), 0)
Red <- pmax2(sweep(Red, 2, Red.bg), 0)

M_and_U <- .preprocessRaw(
        Red = Red,
        Green = Green,
        locusNames = locusNames,
        TypeI.Red = TypeI.Red,
        TypeI.Green = TypeI.Green,
        TypeII = TypeII)
M <- M_and_U[["M"]]
U <- M_and_U[["U"]]



RGset_prep <- MethylSet(
        Meth = M,
        Unmeth = U,
        colData = colData(RGset),
        annotation = annotation(RGset),
        metadata = metadata(RGset))
```

#QC with funcnorm and BGcorr
Normalisation should not be affected by sample, hence all samples are included in this step 
```{r QC and normalisation}
# QC - pre-normalisation
pdf("plots/QC_pre_norm_densityBean.pdf")
par(mar=c(5,10,4,2))
densityBeanPlot(RGset_raw,sampNames = pData(RGset)$Sample_Name)
dev.off()

#1000 most variable postion 2d projection prior to normalisation
pdf("plots/QC_pre_norm_1000_most_variable_position_MDS.pdf")
mdsPlot(as.matrix(getBeta(RGset_raw)), sampNames = pData(RGset)$Sample_Name)
dev.off()


# QC - post-normalisation
pdf("plots/QC_post_norm_1000_most_variable_position_MDS.pdf")
mdsPlot(as.matrix(getBeta(RGset_prep)), sampNames = pData(RGset_prep)$Sample_Name)
dev.off()

pdf("plots/QC_pos_norm_densityBean.pdf")
par(mar=c(5,10,4,2))
densityBeanPlot(RGset_prep,sampNames =pData(RGset_prep)$Sample_Name)
dev.off()
```
sanity check using BRCA1 for normalisation
```{r}

TCGA_brca1_promo_start = 43125041
TCGA_brca1_promo_end = 43125714
brca1_CpG <- annotation %>%
  filter(CHR == "chr17", MAPINFO>= TCGA_brca1_promo_start , MAPINFO <= TCGA_brca1_promo_end)

pdf("plots/QC_normalised_BRCA1_promoter.pdf")
getBeta(RGset_prep) %>%
  `colnames<-` (pData(RGset)$Sample_Name) %>%
  as.data.frame() %>%
  rownames_to_column("Name") %>%
  filter(Name %in% brca1_CpG$Name) %>%
  gather(key = "cell_line", value = "beta", -"Name")%>%
  mutate(Name = factor(Name, levels = unique(brca1_CpG$Name[order(brca1_CpG$MAPINFO)]))) %>%
  ggplot(aes(x = Name, y = beta, group = cell_line, color = cell_line))+
                geom_point(alpha = 0.7) +
                geom_line(alpha = 0.3)+
                theme(axis.text.x = element_text(angle = 90, vjust = 0.5))+
  ggtitle("normalised_brca1_promoter")
dev.off()

pdf("plots/QC_raw_BRCA1_promoter.pdf")
getBeta(RGset_raw)%>%
  `colnames<-` (pData(RGset)$Sample_Name) %>%
  as.data.frame() %>%
  rownames_to_column("Name") %>%
  filter(Name %in% brca1_CpG$Name) %>%
  gather(key = "cell_line", value = "beta", -"Name")%>%
  mutate(Name = factor(Name, levels = unique(brca1_CpG$Name[order(brca1_CpG$MAPINFO)]))) %>%
  ggplot(aes(x = Name, y = beta, group = cell_line, color = cell_line))+
                geom_point(alpha = 0.7) +
                geom_line(alpha = 0.3)+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))+
   ggtitle("raw_brca1_promoter")

dev.off()

```
62 parent is the untreated baseline methylation level 
62GSK5 is the treated cell line with one dose of GSK5, the followed suffix of 1, 2, 3, 4 suggested for 4 different timepoints post treatment recovery.
Here, we want to test whether cellline return to the baseline post treatment recovery

interestingly, we can already see something from the MDS plot
1-4 timepoints cluster together that is distant from 62 parent, suggesting no full recovery
if that's the case, then I am wondering how different it is between timepoint 1 and 4

since they have been normalised, lets use 0.25 as the cut-off to extract location that has been changing overtime :)
```{r}
timeseries = c("62_parent", "62GSK5_FB_1", "62GSK5_FB_2", "62GSK5_FB_3", "62GSK5_FB_4")
comparison = as.data.frame((getBeta(RGset_prep)%>%
  `colnames<-` (pData(RGset)$Sample_Name))[,timeseries])

changed_CpG <- comparison %>%
  mutate(bl_1 = if_else(abs(`62GSK5_FB_1` - `62_parent`) >= 0.25, `62GSK5_FB_1` - `62_parent`, 0),
         bl_2 = if_else(abs(`62GSK5_FB_2` - `62_parent`) >= 0.25, `62GSK5_FB_2` - `62_parent`, 0),
         bl_3 = if_else(abs(`62GSK5_FB_3` - `62_parent`) >= 0.25, `62GSK5_FB_3` - `62_parent`, 0),
         bl_4 = if_else(abs(`62GSK5_FB_4` - `62_parent`) >= 0.25, `62GSK5_FB_4` - `62_parent`, 0)) %>%
  filter(bl_1+bl_2+bl_3+bl_4 != 0)
```

There are 418235/933252 CpGs that have changes over treatment or at least varied from treatment using the cutoff of 0.25

comparison between baseline and treated 
```{r}
comparison %>%
  ggplot(aes(x = `62_parent`, y = `62GSK5_FB_1`)) +
  geom_bin2d(bins =500)+
stat_cor(method = "pearson")+
   scale_fill_gradient(name = "count",trans = "log2", breaks = c(1,4,16,64,512))+
  theme_bw()+
  ggtitle("time point 1 vs baseline")
ggsave("plots/scatter_timepoint1_baseline.pdf")

comparison %>%
  ggplot(aes(x = `62_parent`, y = `62GSK5_FB_2`)) +
  geom_bin2d(bins =500)+
  stat_cor(method = "pearson")+
  scale_fill_gradient(name = "count",trans = "log2", breaks = c(1,4,16,64,512))+
  theme_bw()+
  ggtitle("time point 2 vs baseline")
ggsave("plots/scatter_timepoint2_baseline.pdf")

comparison %>%
  ggplot(aes(x = `62_parent`, y = `62GSK5_FB_3`)) +
  geom_bin2d(bins =500)+
  stat_cor(method = "pearson")+
  scale_fill_gradient(name = "count",trans = "log2", breaks = c(1,4,16,64,512))+
  theme_bw()+
  ggtitle("time point 3 vs baseline")
ggsave("plots/scatter_timepoint3_baseline.pdf")

comparison %>%
  ggplot(aes(x = `62_parent`, y = `62GSK5_FB_4`)) +
  geom_bin2d(bins =500)+
  stat_cor(method = "pearson")+
  scale_fill_gradient(name = "count",trans = "log2", breaks = c(1,4,16,64,512))+
  theme_bw()+
  ggtitle("time point 4 vs baseline")
ggsave("plots/scatter_timepoint4_baseline.pdf")

```

# heatmap on changes of beta value on binned island
```{r}
CpG <- comparison %>%
  mutate(timepoint1 = `62GSK5_FB_1`- `62_parent`,
         timepoint2 = `62GSK5_FB_2`- `62_parent`,
         timepoint3 = `62GSK5_FB_3`- `62_parent`,
         timepoint4 = `62GSK5_FB_4`- `62_parent`) %>%
  dplyr::select(-starts_with("62")) %>%
  rownames_to_column("Name") %>%
  left_join(annotation%>%
              as.data.frame() %>%
              dplyr::select(Name, CHR, MAPINFO, UCSC_CpG_Islands_Name, Relation_to_UCSC_CpG_Island, Regulatory_Feature_Group, GencodeV41_Group), by = "Name")%>%
  separate_rows(c("Relation_to_UCSC_CpG_Island", "UCSC_CpG_Islands_Name"), sep = ";")

island <- CpG %>%
  filter(str_detect(Relation_to_UCSC_CpG_Island, "Island")) %>%
  # group_by(UCSC_CpG_Islands_Name) %>%
  # filter(sum(str_detect(GencodeV41_Group, "TSS")) > 0) %>%
  ungroup()


heatmap_mat <- island %>%
  dplyr::select(-Relation_to_UCSC_CpG_Island) %>%
  mutate(chr = sapply(UCSC_CpG_Islands_Name, function(x) unlist(strsplit(x, split = ":"))[1]),
         position = sapply(UCSC_CpG_Islands_Name, function(x) unlist(strsplit(x, split = ":"))[2])) %>%
  separate(position, into = c("start", "end"), sep = "-") %>%
  mutate(start = as.numeric(start), end = as.numeric(end),
         island_width  = end - start, bin_width = island_width /3,
         assigned_bin = ceiling((MAPINFO - start)/bin_width)) %>%
  pivot_longer(cols = c("timepoint1", "timepoint2", "timepoint3", "timepoint4"), names_to = "timepoint", values_to = "beta") %>%
  group_by(UCSC_CpG_Islands_Name, assigned_bin, timepoint) %>%
  summarise(methylation = mean(beta)) %>%
  pivot_wider(names_from = assigned_bin, values_from = methylation) 

order = heatmap_mat %>%
  group_by(UCSC_CpG_Islands_Name) %>%
  summarise(total = sum(`1`, na.rm = T) + sum(`3`, na.rm = T) + sum(`3`, na.rm = T)) %>%
  arrange(desc(total))

library(circlize)
col_fun = colorRamp2(c(-1, 0, 1), c("blue", "white", "red"))

time1 = ComplexHeatmap::Heatmap((heatmap_mat[which(heatmap_mat$timepoint == "timepoint1"),] %>%
           column_to_rownames("UCSC_CpG_Islands_Name") %>%
           dplyr::select(as.character(seq(1,3))) %>%
                           as.matrix())[order$UCSC_CpG_Islands_Name,],cluster_columns = F, cluster_rows = F, show_row_names = F, col = col_fun)

time2 =ComplexHeatmap::Heatmap((heatmap_mat[which(heatmap_mat$timepoint == "timepoint2"),] %>%
           column_to_rownames("UCSC_CpG_Islands_Name") %>%
           dplyr::select(as.character(seq(1,3)))%>%
                           as.matrix())[order$UCSC_CpG_Islands_Name,],cluster_columns = F, cluster_rows = F, show_row_names = F, col = col_fun, show_heatmap_legend = F)

time3 =ComplexHeatmap::Heatmap((heatmap_mat[which(heatmap_mat$timepoint == "timepoint3"),] %>%
           column_to_rownames("UCSC_CpG_Islands_Name") %>%
           dplyr::select(as.character(seq(1,3)))%>%
                           as.matrix())[order$UCSC_CpG_Islands_Name,],cluster_columns = F, cluster_rows = F, show_row_names = F, col = col_fun, show_heatmap_legend = F)

time4 =ComplexHeatmap::Heatmap((heatmap_mat[which(heatmap_mat$timepoint == "timepoint4"),] %>%
           column_to_rownames("UCSC_CpG_Islands_Name") %>%
           dplyr::select(as.character(seq(1,3)))%>%
                           as.matrix())[order$UCSC_CpG_Islands_Name,],cluster_columns = F, cluster_rows = F, show_row_names = F, col = col_fun, show_heatmap_legend = F)
pdf("plots/island_timepoints.pdf")
draw(time1+time2+time3+time4)
dev.off()
```
```{r}
N_shore <- CpG %>%
  filter(str_detect(Relation_to_UCSC_CpG_Island, "Shore")) 

N_shore$UCSC_CpG_Islands_Name_island <- unlist(strsplit(N_shore$UCSC_CpG_Islands_Name, split= ";"))[which(unlist(lapply(strsplit(N_shore$Relation_to_UCSC_CpG_Island, split= ";"), function(x) x =="N_Shore")))]

heatmap_mat <- island %>%
  dplyr::select(-UCSC_CpG_Islands_Name, -Relation_to_UCSC_CpG_Island) %>%
  mutate(chr = sapply(UCSC_CpG_Islands_Name_island, function(x) unlist(strsplit(x, split = ":"))[1]),
         position = sapply(UCSC_CpG_Islands_Name_island, function(x) unlist(strsplit(x, split = ":"))[2])) %>%
  separate(position, into = c("start", "end"), sep = "-") %>%
  mutate(start = as.numeric(start), end = as.numeric(end),
         island_width  = end - start, bin_width = island_width /3,
         assigned_bin = ceiling((MAPINFO - start)/bin_width)) %>%
  pivot_longer(cols = c("timepoint1", "timepoint2", "timepoint3", "timepoint4"), names_to = "timepoint", values_to = "beta") %>%
  group_by(UCSC_CpG_Islands_Name_island, assigned_bin, timepoint) %>%
  summarise(methylation = mean(beta)) %>%
  pivot_wider(names_from = assigned_bin, values_from = methylation) 

order = heatmap_mat %>%
  group_by(UCSC_CpG_Islands_Name_island) %>%
  summarise(total = sum(`1`, na.rm = T) + sum(`3`, na.rm = T) + sum(`3`, na.rm = T)) %>%
  arrange(desc(total))

```
```{r directional change}
directionCpG <- changed_CpG %>%
  dplyr::select(-starts_with("62")) %>%
  rownames_to_column("Name") %>%
  gather(key = "comparison", value = "delta_beta", -"Name") %>%
  left_join(annotation%>%
              as.data.frame() %>%
              dplyr::select(annotation_rows) %>%
              filter(Name %in% rownames(changed_CpG)), by = "Name")  %>%
  distinct()%>%  
  group_by(Name) %>%
  summarise(`Methylated to baseline` = sum(delta_beta >0), `Demethylated to baseline` = -sum(delta_beta < 0 ), Relation_to_UCSC_CpG_Island, Regulatory_Feature_Group)

directionCpG %>%
  ungroup()%>%
  mutate(change = case_when(`Methylated to baseline` ==0 & `Demethylated to baseline` != 0 ~ "Demeth/Transient Demeth",
                            `Methylated to baseline` !=0 & `Demethylated to baseline` == 0 ~ "Meth/Transient Meth",
                            `Methylated to baseline` !=0 & `Demethylated to baseline` != 0 ~ "?variable Meth/Demeth"),
         transient = case_when(`Methylated to baseline` ==4 |`Demethylated to baseline` == -4 ~ "No",
                               TRUE ~"Yes")) %>%
  group_by(change, transient) %>%
  summarise(n=n()) %>%
  ungroup() %>%
  mutate(percent = n/sum(n))

#manually inspect sites with methylation and demethylation
#these probes are likely to be variable methylation sites. I will remove them
# 275 sites
#regulatory component
directionCpG %>%
  # filter(str_detect(pattern = "Island", string = Relation_to_UCSC_CpG_Island)) %>%
  ungroup() %>%
  group_by(`Methylated to baseline` ,`Demethylated to baseline`, Regulatory_Feature_Group) %>%
  summarise(n=n()) %>%
  ungroup() %>%
  mutate(change_direction = paste(`Methylated to baseline` ,`Demethylated to baseline`, sep = ";"),
         change_direction = factor(change_direction, levels = c("0;-4", "0;-3", "0;-2", "0;-1", "1;-3", "1;-2", "1;-1", "2;-1", "3;-1",  "1;0","2;0", "3;0", "4;0"))) %>%
  ggplot(aes(x = change_direction, y = n, fill = Regulatory_Feature_Group)) +
  geom_bar(stat= "identity", position = "dodge", color = "black")+
  scale_y_continuous(trans = log2_trans(), breaks = trans_breaks("log10", function(x) 10^x),
    labels = trans_format("log10", math_format(10^.x)))+
  scale_fill_brewer(palette = "Set3")+
  facet_wrap(~Regulatory_Feature_Group)+
  theme_bw()
  
  
ggsave("plots/relative_change_regulatory_element.pdf", height = 10, width = 15) 



directionCpG %>%
  # filter(!(`Methylated to baseline` != 0 & `Demethylated to baseline` != 0)) %>%
  ungroup() %>%
  group_by(`Methylated to baseline` ,`Demethylated to baseline`, Relation_to_UCSC_CpG_Island) %>%
  summarise(n=n()) %>%
  ungroup() %>%
  mutate(change_direction = paste(`Methylated to baseline` ,`Demethylated to baseline`, sep = ";"),
         change_direction = factor(change_direction, levels = c("0;-4", "0;-3", "0;-2", "0;-1", "1;-3", "1;-2", "1;-1", "2;-1", "3;-1",  "1;0","2;0", "3;0", "4;0")),
         Relation_to_UCSC_CpG_Island = sapply(Relation_to_UCSC_CpG_Island, function(x) paste(unique(unlist(strsplit(gsub("N_|S_", "", x), split = ";"))), collapse = ";"))) %>%
  ggplot(aes(x = change_direction, y = n, fill = Relation_to_UCSC_CpG_Island)) +
  geom_bar(stat= "identity", position = "dodge", color = "black")+
  scale_y_continuous(trans = log2_trans(), breaks = trans_breaks("log10", function(x) 10^x),
    labels = trans_format("log10", math_format(10^.x)))+
  scale_fill_brewer(palette = "Set3")+
  facet_wrap(~Relation_to_UCSC_CpG_Island)+
  theme_bw()
  
  
```
```{r}

timeseries_col = c("62_parent" = "black",  "62GSK5_FB_1" = "#d9ed92",  "62GSK5_FB_2" = "#76c893", "62GSK5_FB_3" = "#168aad", "62GSK5_FB_4" = "#1e6091")

changed_CpG_df <- changed_CpG %>%
  dplyr::select(-starts_with("bl_")) %>%
  rownames_to_column("Name") %>%
  gather(key = "cell_line", value = "beta", -"Name") %>%
  left_join(annotation%>%
              as.data.frame() %>%
              dplyr::select(annotation_rows) %>%
              filter(Name %in% rownames(changed_CpG)) %>%
              distinct(), by = "Name") %>%
  filter(!is.na(Name), !is.na(CHR), !is.na(MAPINFO))

changed_CpG_df %>%
  filter(str_detect(Regulatory_Feature_Group, "Promoter"), !CHR =="chrY") %>%
  ggplot(aes(x = MAPINFO, y = beta, color = cell_line, group = cell_line))+
  geom_line(size = 0.4)+
  facet_grid(rows = vars(CHR), scales = "free_x", space = "free")+
  scale_color_manual(values= timeseries_col)
ggsave("plots/promoter_cpgisland_beta.pdf", width = 10, height= 20 )



```









```{r}
library("GenomicRanges")
changed_CpG_df <- changed_CpG %>%
  dplyr::select(-starts_with("bl_")) %>%
  rownames_to_column("Name") %>%
  gather(key = "cell_line", value = "beta", -"Name") %>%
  left_join(annotation%>%
              as.data.frame() %>%
              dplyr::select(annotation_rows) %>%
              filter(Name %in% rownames(changed_CpG)), by = "Name") %>%
  filter(!is.na(Name), !is.na(CHR), !is.na(MAPINFO))

```

visualise them on a karyoplot may help with their location?
```{r plot karyoplot}
library("karyoploteR")

timeseries_col = c("62_parent" = "black",  "62GSK5_FB_1" = "#d9ed92",  "62GSK5_FB_2" = "#76c893", "62GSK5_FB_3" = "#168aad", "62GSK5_FB_4" = "#1e6091")

changedCpGgrange <- makeGRangesFromDataFrame(changed_CpG_df %>%
                                               mutate(col = alpha(timeseries_col[cell_line], 0.2)) %>%
                                               filter(!is.na(pos)), keep.extra.columns = T, ignore.strand = T, start.field = "pos", end.field = "pos")
pdf("plots/genomic_loc_changed_CpG_with_treatment.pdf", height = 12, width = 10)
kp <- plotKaryotype(plot.type = 2, chromosomes = paste0("chr",seq(1:22)))
kpPoints(kp,data = changedCpGgrange, y = changedCpGgrange@elementMetadata@listData$beta, col =  changedCpGgrange@elementMetadata@listData$col, cex = 0.6)
kpPlotDensity(kp, data=changedCpGgrange, data.panel=2, col=alpha ("grey", 0.7), r0=0, r1=1)
legend(x = "bottomright", col = c("black", "#d9ed92", "#76c893","#168aad", "#1e6091"), legend = c("Untreated", "Time Point 1", "Time Point 2", "Time Point 3", "Time Point 4"), cex = 0.3, pch = c(20,20,20,20,20 ))
dev.off()
```
karyoplot are too crowded for the detailed difference
```{r zoom in difference}
changed_CpG_df %>%
  ggplot(aes(y = beta, x = Name, color = cell_line))+
geom_point()+
  scale_color_manual(values = timeseries_col)+
  facet_wrap(~Relation_to_Island, scales = "free")+
  theme_bw()+
  theme(legend.position = "bottom", axis.text.x = element_blank(), axis.ticks.x = element_blank())+
  ggtitle("Beta value at changed CpG probes")

ggsave("plots/absolute_beta_value_at_changedCpG.pdf", height = 6, width = 10)

timeseries_relative_col = c("bl_1" = "#d9ed92",  "bl_2" = "#76c893", "bl_3" = "#168aad", "bl_4" = "#1e6091")
changed_CpG %>%
  dplyr::select(-starts_with("62")) %>%
  rownames_to_column("Name") %>%
  gather(key = "comparison", value = "delta_beta", -"Name") %>%
  left_join(annotation%>%
              as.data.frame() %>%
              dplyr::select(annotation_rows) %>%
              filter(Name %in% rownames(changed_CpG)), by = "Name") %>%
  filter(!is.na(chr), !is.na(pos)) %>%
  ggplot(aes(y = delta_beta, x = Name, color = comparison))+
geom_jitter()+
  scale_color_manual(values = timeseries_relative_col)+
  facet_wrap(~Relation_to_Island, scales = "free")+
  geom_hline(yintercept = 0)+
  theme_bw()+
  theme(legend.position = "bottom", axis.text.x = element_blank(), axis.ticks.x = element_blank())+
  ggtitle("Relative Beta value change at changed CpG probes")
 ggsave("plots/relative_beta_value_at_changedCpG.pdf", height = 6, width = 10) 
  
  
```

now that I noticed one thing I did not consider. the direction of change.
The hypothesis would be GSK cause global demethylation
so we should split changes to demethylation to untreated or methylated to treated 

out of 208 CpG probes 78 CpG demethylated from the GSK treatment , 131 CpG methylated from the GSK treatment

```{r}
#dmp between treated and untreated (not the best approach)
# dmpFinder(norm_beta[,c("62GSK5_FB_1", "62GSK5_FB_2", "62GSK5_FB_3", "62GSK5_FB_4", "62_parent")], pheno = c("treated", "treated", "treated", "treated", "control"), qCutoff = 0.05)


```
