---
title: "Epic_preprocessing"
author: "lijunx"
date: "June 12, 2023"
output: html_document
---

```{r setup, include=FALSE}
library("minfi")
library("tidyverse")
library("ggplot2")
library("ggpubr")
library("data.table")
library("DelayedArray")
library("BiocParallel")
library("scales")
library("ComplexHeatmap")
```



The EPIC array used is version2, which does not have full support from minfi yet. Hence supporting document of annotation was manually downloaded from Illumina "https://support.illumina.com/array/array_kits/infinium-methylationepic-beadchip-kit/downloads.html" (14th JUN 2023)
We will need to construct annotation manually
```{r construct manifest}
#load annotation
annotation <- fread("supporting/EPIC-8v2-0_A1.csv", header = T, skip ="IlmnID")

IlluminaHumanMethylationEPICv2 <- IlluminaMethylationManifest(TypeControl = DataFrame(annotation %>%
                                                                filter(is.na(Infinium_Design), !is.na(Name)) %>%
                                                                dplyr::select(Address = IlmnID, Type = Name, color = AddressA_ID, ExtendedType = AlleleA_ProbeSeq)) ,
                                                              TypeI = DataFrame(annotation %>%
                                                                filter(Infinium_Design_Type == "I", startsWith(Name, "cg")) %>%
                                                                dplyr::select(Name, AddressA = AddressA_ID, AddressB =AddressB_ID, Color = Color_Channel, NextBase = Next_Base, ProbeSeqA = AlleleA_ProbeSeq, ProbeSeqB = AlleleB_ProbeSeq, nCpG = Rep_Num)),
                                                              TypeII = DataFrame(annotation %>%
                                                                filter(Infinium_Design_Type == "II", startsWith(Name, "cg"))  %>%
                                                                dplyr::select(Name, AddressA = AddressA_ID, AddressB =AddressB_ID, Color = Color_Channel, NextBase = Next_Base, ProbeSeqA = AlleleA_ProbeSeq, ProbeSeqB = AlleleB_ProbeSeq, nCpG = Rep_Num)),
                                                              TypeSnpI = DataFrame(annotation %>%
                                                                filter(Infinium_Design_Type == "I", 
                                                                       startsWith(Name, "rs")) %>%
                                                                dplyr::select(Name, AddressA = AddressA_ID, 
                                                                              AddressB = AddressB_ID, 
                                                                              Color = Color_Channel, 
                                                                              NextBase = Next_Base, 
                                                                              ProbeSeqA = AlleleA_ProbeSeq, 
                                                                              ProbeSeqB = AlleleB_ProbeSeq, 
                                                                              nCpG = Rep_Num)),
                                                              TypeSnpII = DataFrame(annotation %>%
                                                                filter(Infinium_Design_Type == "II", 
                                                                       startsWith(Name, "rs")) %>%
                                                                dplyr::select(Name, AddressA = AddressA_ID, 
                                                                              AddressB = AddressB_ID, 
                                                                              Color = Color_Channel, 
                                                                              NextBase = Next_Base, 
                                                                              ProbeSeqA = AlleleA_ProbeSeq, 
                                                                              ProbeSeqB = AlleleB_ProbeSeq, 
                                                                              nCpG = Rep_Num)),
                                                              annotation = "IlluminaHumanMethylationEPICV2")
                                                              
```


```{r load file}
# loading epic array
raw_data_dir = "raw"
target = read.metharray.sheet(raw_data_dir)
RGset <- read.metharray.exp(targets= target, verbose = F, extended = F)

annotation_rows <- c("Name","MAPINFO", "CHR", "UCSC_CpG_Islands_Name", "HMM_Island", "OpenChromatin_NAME", "Regulatory_Feature_Name","Regulatory_Feature_Group" , "GencodeV41_Name", "Phantom5_Enhancers", "Relation_to_UCSC_CpG_Island", "UCSC_RefGene_Name" )

timeseries_col = c("62_Untreated" = "#22577a",  "62_DMNT1i_T1" = "#38a3a5",  "62_DMNT1i_T2" = "#57cc99", "62_DMNT1i_T3" = "#80ed99", "62_DMNT1i_T4" = "#c7f9cc", "OVCAR8_Untreated" = "#e36414", "OVCAR8_DMNT1i" = "#faa307", "PH039" = "#9d4edd")

Sample_Name <- c("62_DMNT1i_T1", "62_DMNT1i_T2", "62_DMNT1i_T3", "62_DMNT1i_T4", "62_Untreated", "OVCAR8_DMNT1i", "OVCAR8_Untreated", "PH039")
```


```{r extract method for manual processing}
.highestType <- function(...) {
    dots <- list(...)
    types <- vapply(dots, DelayedArray::type, character(1L))
    vector <- do.call(c, lapply(types, vector))  # guaranteed to be atomic
    typeof(vector)
}

.NA_type <- function(type) {
    c(vector(type), NA)
}
setGeneric(
    ".preprocessRawMeth",
    function(Red, Green, locusNames, TypeI.Red, TypeI.Green, TypeII, ...)
        standardGeneric(".preprocessRawMeth"),
    signature = c("Red", "Green"))

# `...` are additional arguments passed to methods.
setGeneric(
    ".preprocessRawUnmeth",
    function(Red, Green, locusNames, TypeI.Red, TypeI.Green, TypeII, ...)
        standardGeneric(".preprocessRawUnmeth"),
    signature = c("Red", "Green"))

# `...` are additional arguments passed to methods.
setGeneric(
    ".preprocessRaw",
    function(Red, Green, locusNames, TypeI.Red, TypeI.Green, TypeII, ...)
        standardGeneric(".preprocessRaw"),
    signature = c("Red", "Green"))

setMethod(
    ".preprocessRawMeth",
    c("matrix", "matrix"),
    function(Red, Green, locusNames, TypeI.Red, TypeI.Green, TypeII) {
        # Set up output matrix with appropriate dimension and type
        type <- .highestType(Red, Green)
        M <- matrix(.NA_type(type),
                    nrow = length(locusNames),
                    ncol = ncol(Red),
                    dimnames = list(locusNames, colnames(Red)))

        # Fill output matrix
        M[TypeI.Red$Name, ] <- Red[TypeI.Red$AddressB, ]
        M[TypeI.Green$Name, ] <- Green[TypeI.Green$AddressB, ]
        M[TypeII$Name, ] <- Green[TypeII$AddressA, ]

        # Return output matrix
        M
    }
)

setMethod(
    ".preprocessRawUnmeth",
    c("matrix", "matrix"),
    function(Red, Green, locusNames, TypeI.Red, TypeI.Green, TypeII, ...) {
        # Set up output matrix with appropriate dimension and type
        type <- .highestType(Red, Green)
        U <- matrix(.NA_type(type),
                    nrow = length(locusNames),
                    ncol = ncol(Red),
                    dimnames = list(locusNames, colnames(Red)))

        # Fill output matrix
        U[TypeI.Red$Name, ] <- Red[TypeI.Red$AddressA, ]
        U[TypeI.Green$Name, ] <- Green[TypeI.Green$AddressA, ]
        U[TypeII$Name, ] <- Red[TypeII$AddressA, ]

        # Return output matrix
        U
    }
)

setMethod(
    ".preprocessRaw",
    c("matrix", "matrix"),
    function(Red, Green, locusNames, TypeI.Red, TypeI.Green, TypeII, ...) {
        list(
            M = .preprocessRawMeth(
                Red, Green, locusNames, TypeI.Red, TypeI.Green, TypeII),
            U = .preprocessRawUnmeth(
                Red, Green, locusNames, TypeI.Red, TypeI.Green, TypeII))
    }
)

blockMapplyWithRealization <- function(FUN, ..., MoreArgs = NULL, sinks = NULL,
                                       dots_grids = NULL, sinks_grids = NULL,
                                       BPREDO = list(), BPPARAM = bpparam()) {
    FUN <- match.fun(FUN)
    dots <- unname(list(...))
    # Check valid `sinks`
    stopifnot(is.null(sinks) || is.list(sinks))
    # Check conformable dots_grids and sinks_grids
    if (is.null(dots_grids)) {
        dots_grids <- replicate(length(dots), NULL)
    } else {
        stopifnot(is.list(dots_grids))
    }
    dots_grids <- mapply(
        FUN = DelayedArray:::normarg_grid,
        dots_grids,
        dots,
        SIMPLIFY = FALSE,
        USE.NAMES = FALSE)
    if (is.null(sinks_grids)) {
        sinks_grids <- replicate(length(sinks), NULL)
    } else {
        stopifnot(is.list(sinks_grids))
    }
    sinks_grids <- mapply(
        FUN = DelayedArray:::normarg_grid,
        sinks_grids,
        sinks,
        SIMPLIFY = FALSE,
        USE.NAMES = FALSE)
    grids_dims <- lapply(c(dots_grids, sinks_grids), dim)
    all_same_grids_dims <- all(
        vapply(X = grids_dims,
               FUN = function(dim) all(dim == grids_dims[[1L]]),
               FUN.VALUE = logical(1L)))
    if (!all_same_grids_dims) {
        stop("non-conformable 'dots_grids' and 'sinks_grids'")
    }
    stopifnot(length(dots) == length(dots_grids),
              length(sinks) == length(sinks_grids))

    # Loop over blocks of `dots` and write to `sinks`
    nblock <- length(dots_grids[[1]])
    bplapply(seq_len(nblock), function(b) {
        if (DelayedArray:::get_verbose_block_processing()) {
            message("Processing block ", b, "/", nblock, " ... ",
                    appendLF = FALSE)
        }
        input_viewports <- lapply(dots_grids, function(grid) grid[[b]])
        output_viewports <- lapply(sinks_grids, function(grid) grid[[b]])
        blocks <- mapply(
            FUN = function(x, grid, viewport) {
                block <- read_block(x, viewport)
                attr(block, "from_grid") <- grid
                attr(block, "block_id") <- b
                block
            },
            x = dots,
            grid = dots_grids,
            viewport = input_viewports,
            SIMPLIFY = FALSE,
            USE.NAMES = FALSE)
        block_ans <- do.call(FUN, c(blocks, MoreArgs))
        if (!is.list(block_ans)) {
            block_ans <- list(block_ans)
        }
        # NOTE: This is the only part different from blockMapply()
        if (!is.null(sinks)) {
            mapply(function(ans, sink, viewport) {
                write_block(sink, viewport, ans)
            }, ans = block_ans, sink = sinks, viewport = output_viewports,
            SIMPLIFY = FALSE, USE.NAMES = FALSE)
            block_ans <- NULL
        }
        if (DelayedArray:::get_verbose_block_processing()) {
            message("OK")
        }
        block_ans
    },
    BPREDO = ,
    BPPARAM = bpparam())
}

```

```{r manual preprocessing raw methylation array}
#control normalisation and background correction
Green <- getGreen(RGset)
Red <- getRed(RGset)

AT.controls <- getControlAddress(
            object = IlluminaHumanMethylationEPICv2,
            controlType = c("NORM_A", "NORM_T"))
CG.controls <- getControlAddress(
            object = IlluminaHumanMethylationEPICv2,
            controlType = c("NORM_C", "NORM_G"))

assay(RGset, "Green") <- Green
assay(RGset, "Red") <- Red


#manually load into methylset to access available mapping
TypeI.Red <- getProbeInfo(IlluminaHumanMethylationEPICv2, type = "I-Red")
TypeI.Green <- getProbeInfo(IlluminaHumanMethylationEPICv2, type = "I-Green")
TypeII <- getProbeInfo(IlluminaHumanMethylationEPICv2, type = "II")
locusNames <- getManifestInfo(IlluminaHumanMethylationEPICv2, "locusNames")
M_and_U <- .preprocessRaw(
        Red = Red,
        Green = Green,
        locusNames = locusNames,
        TypeI.Red = TypeI.Red,
        TypeI.Green = TypeI.Green,
        TypeII = TypeII)
M <- M_and_U[["M"]]
U <- M_and_U[["U"]]


RGset_raw <- MethylSet(
        Meth = M,
        Unmeth = U,
        colData = colData(RGset),
        annotation = annotation(RGset),
        metadata = metadata(RGset))

```
```{r manual preprocessing normalisation methylation array against control probes from bulk62}
#normalisation
Green.avg <- colMeans2(Green, rows = match(CG.controls, rownames(Green)))
Red.avg <- colMeans2(Red, rows = match(AT.controls, rownames(Red)))
ref <- (Green.avg + Red.avg)[1] / 2
Green.factor <- ref / Green.avg
Red.factor <- ref / Red.avg
Green <- sweep(Green, 2, FUN = "*", Green.factor)
Red <- sweep(Red, 2, FUN = "*", Red.factor)

#bg.correction
NegControls <- getControlAddress(IlluminaHumanMethylationEPICv2, controlType = "NEGATIVE")
Green.bg <- apply(Green[NegControls, , drop = FALSE], 2, function(xx) {
        sort(as.vector(xx))[31]})
Red.bg <- apply(Red[NegControls, , drop = FALSE], 2, function(xx) {
        sort(as.vector(xx))[31] })
Green <- pmax2(sweep(Green, 2, Green.bg), 0)
Red <- pmax2(sweep(Red, 2, Red.bg), 0)

M_and_U <- .preprocessRaw(
        Red = Red,
        Green = Green,
        locusNames = locusNames,
        TypeI.Red = TypeI.Red,
        TypeI.Green = TypeI.Green,
        TypeII = TypeII)
M <- M_and_U[["M"]]
U <- M_and_U[["U"]]

RGset_prep <- MethylSet(
        Meth = M,
        Unmeth = U,
        colData = colData(RGset),
        annotation = annotation(RGset),
        metadata = metadata(RGset))

```

#QC with funcnorm and BGcorr
Normalisation should not be affected by sample, hence all samples are included in this step 
```{r QC and normalisation}
# QC - pre-normalisation
pdf("plots/QC_raw_Bean.pdf")
par(mar=c(5,10,4,2))
densityBeanPlot(getBeta(RGset_raw)[,c(8,6,7,4,3,2,1,5)],sampNames = c("PH039", "OVCAR8_DMNT1i", "OVCAR8_Untreated", "62_DMNT1i_T4", "62_DMNT1i_T3", "62_DMNT1i_T2","62_DMNT1i_T1", "62_Untreated"))
dev.off()

#1000 most variable postion 2d projection prior to normalisation
pdf("plots/QC_raw_1000_most_variable_position_MDS.pdf")
mdsPlot(as.matrix(getBeta(RGset_raw)), sampNames = Sample_Name)
dev.off()


# QC - post-normalisation
pdf("plots/QC_post_norm_1000_most_variable_position_MDS.pdf")
mdsPlot(as.matrix(getBeta(RGset_prep)), sampNames = Sample_Name)
dev.off()

pdf("plots/QC_post_norm_densityBean.pdf")
par(mar=c(5,10,4,2))
densityBeanPlot(getBeta(RGset_prep)[,c(8,6,7,4,3,2,1,5)],sampNames = c("PH039", "OVCAR8_DMNT1i", "OVCAR8_Untreated", "62_DMNT1i_T4", "62_DMNT1i_T3", "62_DMNT1i_T2","62_DMNT1i_T1", "62_Untreated"))
dev.off()

# density plot for parallele comparison of beta distribution to other literature
data.frame(getBeta(RGset_raw)) %>%
`colnames<-` (Sample_Name) %>%
rownames_to_column("CpG") %>%
  gather(key = "cell_line", value = "beta", -CpG) %>%
  ggplot(aes(x = beta, color = cell_line))+
  geom_density()+
  scale_colour_manual(values = timeseries_col)

ggsave("plots/QC_raw_density.pdf")
  

data.frame(getBeta(RGset_prep)) %>%
`colnames<-` (Sample_Name) %>%
rownames_to_column("CpG") %>%
  gather(key = "cell_line", value = "beta", -CpG) %>%
  ggplot(aes(x = beta, color = cell_line))+
  geom_density()+
  scale_colour_manual(values = timeseries_col)

ggsave("plots/QC_post_norm_density.pdf")
  
```
```{r tsne}
library("Rtsne")
tSNE_fit <- na.omit(getBeta(RGset_prep)) %>%
  t() %>%
  Rtsne(perplexity = 2, num_threads = 2)

tSNE_df <- tSNE_fit$Y %>% 
  as.data.frame() %>%
  rename(tSNE1="V1",
         tSNE2="V2")
tSNE_df$ID = pData(RGset_prep)$Sample_Name


tSNE_df %>%
  ggplot(aes(x = tSNE1, 
             y = tSNE2,
             color = ID))+
  geom_point()+
  theme(legend.position = "bottom")
```
sanity check using BRCA1 for normalisation
```{r}
TCGA_brca1_promo_start = 43125041
TCGA_brca1_promo_end = 43125714
brca1_CpG <- annotation %>%
  filter(CHR == "chr17", MAPINFO>= TCGA_brca1_promo_start , MAPINFO <= TCGA_brca1_promo_end)

pdf("plots/QC_norm_BRCA1_promoter.pdf")
getBeta(RGset_prep) %>%
  `colnames<-` (Sample_Name) %>%
  as.data.frame() %>%
  rownames_to_column("Name") %>%
  filter(Name %in% brca1_CpG$Name) %>%
  gather(key = "cell_line", value = "beta", -"Name")%>%
  mutate(Name = factor(Name, levels = unique(brca1_CpG$Name[order(brca1_CpG$MAPINFO)]))) %>%
  ggplot(aes(x = Name, y = beta, group = cell_line, color = cell_line))+
                geom_point(alpha = 0.7) +
                geom_line(alpha = 0.3)+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))+
  scale_color_manual(values = timeseries_col)+
  ggtitle("norm_brca1_promoter")
dev.off()

library(ggbeeswarm)

getBeta(RGset_prep) %>%
  `colnames<-` (Sample_Name) %>%
  as.data.frame() %>%
  rownames_to_column("Name") %>%
  filter(Name %in% brca1_CpG$Name) %>%
  gather(key = "cell_line", value = "beta", -"Name")%>%
  mutate(Name = factor(Name, levels = unique(brca1_CpG$Name[order(brca1_CpG$MAPINFO)])),
         cell_line = factor(cell_line, levels = c("62_Untreated", "62_DMNT1i_T1", "62_DMNT1i_T2", "62_DMNT1i_T3", "62_DMNT1i_T4", "OVCAR8_Untreated", "OVCAR8_DMNT1i", "PH039"))) %>%
  ggplot(aes(x = cell_line, y = beta, color = cell_line))+
  scale_color_manual(values = timeseries_col)+
  geom_boxplot(outlier.shape = NA)+
  geom_beeswarm(size = 1.2)+
  theme_bw()+
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())+
  scale_y_continuous(n.breaks = 10)
  
ggsave("plots/QC_norm_BRCA1_promoter_distribution.pdf")


pdf("plots/QC_raw_BRCA1_promoter.pdf")
getBeta(RGset_raw)%>%
  `colnames<-` (Sample_Name) %>%
  as.data.frame() %>%
  rownames_to_column("Name") %>%
  filter(Name %in% brca1_CpG$Name) %>%
  gather(key = "cell_line", value = "beta", -"Name")%>%
  mutate(Name = factor(Name, levels = unique(brca1_CpG$Name[order(brca1_CpG$MAPINFO)]))) %>%
  ggplot(aes(x = Name, y = beta, group = cell_line, color = cell_line))+
                geom_point(alpha = 0.7) +
                geom_line(alpha = 0.3)+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))+
  scale_color_manual(values = timeseries_col)+
   ggtitle("raw_brca1_promoter")

dev.off()

```
62 parent is the untreated baseline methylation level 
62GSK5 is the treated cell line with one dose of GSK5, the followed suffix of 1, 2, 3, 4 suggested for 4 different timepoints post treatment recovery.
Here, we want to test whether cellline return to the baseline post treatment recovery

interestingly, we can already see something from the MDS plot
1-4 timepoints cluster together that is distant from 62 parent, suggesting no full recovery
if that's the case, then I am wondering how different it is between timepoint 1 and 4
```{r}
timeseries = c("62_Untreated", "62_DMNT1i_T1","62_DMNT1i_T2","62_DMNT1i_T3","62_DMNT1i_T4",  "OVCAR8_Untreated", "OVCAR8_DMNT1i")
comparison = as.data.frame((getBeta(RGset_prep)%>%
  `colnames<-` (Sample_Name))) %>%
  filter_at(vars(unlist(timeseries)),all_vars(!is.na(.)))

sum(is.na(comparison$KF5_G10))

```

There are 418235/933252 CpGs that have changes over treatment or at least varied from treatment using the cutoff of 0.25

comparison between baseline and treated on a global level including all the CpG
```{r All CpG scatter plot}
timepoint_1 <- comparison %>%
  ggplot(aes(x = `62_Untreated`, y = `62_DMNT1i_T1`)) +
  geom_bin2d(bins =100)+
   scale_fill_gradient(name = "count",trans = "log2", breaks = c(1,4,16,64,512))+
  theme_bw()

timepoint_2 <-comparison %>%
  ggplot(aes(x = `62_Untreated`, y = `62_DMNT1i_T2`)) +
  geom_bin2d(bins =100)+
  scale_fill_gradient(name = "count",trans = "log2", breaks = c(1,4,16,64,512))+
  theme_bw()

timepoint_3 <-comparison %>%
  ggplot(aes(x = `62_Untreated`, y = `62_DMNT1i_T3`)) +
  geom_bin2d(bins =100)+
  scale_fill_gradient(name = "count",trans = "log2", breaks = c(1,4,16,64,512))+
  theme_bw()

timepoint_4 <-comparison %>%
  ggplot(aes(x = `62_Untreated`, y = `62_DMNT1i_T4`)) +
  geom_bin2d(bins =100)+
  scale_fill_gradient(name = "count",trans = "log2", breaks = c(1,4,16,64,512))+
  theme_bw()

ggarrange(timepoint_1, timepoint_2, timepoint_3, timepoint_4, common.legend = T, legend = "right")

ggsave("plots/scatter_timepoint_baseline.pdf")
```
#join annotation
```{r}
global <- comparison %>%
  rownames_to_column("Name") %>%
  left_join(annotation%>%
              as.data.frame() %>%
              dplyr::select(Name, CHR, MAPINFO, UCSC_CpG_Islands_Name, Relation_to_UCSC_CpG_Island, Regulatory_Feature_Group, GencodeV41_Group), by = "Name")%>%
  separate_rows(c("Relation_to_UCSC_CpG_Island", "UCSC_CpG_Islands_Name"), sep = ";") %>%
  filter(CHR != "chrY") 
```
# Relative to island location and changes in distribution
```{r}

global %>%
  mutate(Relation_to_UCSC_CpG_Island = gsub("N_|S_", "", Relation_to_UCSC_CpG_Island)) %>%
  mutate(Relation_to_UCSC_CpG_Island = if_else(Relation_to_UCSC_CpG_Island == "", "Others", Relation_to_UCSC_CpG_Island))%>%
  distinct() %>%
  pivot_longer(cols = all_of(timeseries), names_to = "cell_line", values_to = "beta") %>%
  mutate(Relation_to_UCSC_CpG_Island = factor(Relation_to_UCSC_CpG_Island, levels = c("Island", "Shore", "Shelf", "Others")),
         cell_line = factor(cell_line, levels = timeseries)) %>%
  ggplot(aes(x = cell_line, fill = cell_line, y = beta))+
  geom_violin(alpha = 0.5)+
  facet_wrap(~Relation_to_UCSC_CpG_Island, nrow = 1)+
  theme_bw()+
  scale_fill_manual(values = timeseries_col, limits = force)+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5))

ggsave("plots/CpG_location_distribution.pdf", width = 15)



diff_global <- global %>%
  mutate(Relation_to_UCSC_CpG_Island = gsub("N_|S_", "", Relation_to_UCSC_CpG_Island)) %>%
  mutate(Relation_to_UCSC_CpG_Island = if_else(Relation_to_UCSC_CpG_Island == "", "Others", Relation_to_UCSC_CpG_Island))%>%
  distinct() %>%
  mutate(Relation_to_UCSC_CpG_Island = factor(Relation_to_UCSC_CpG_Island, levels = c("Island", "Shore", "Shelf", "Others"))) %>%
  dplyr::select(starts_with("62"), Relation_to_UCSC_CpG_Island, Name) %>%
  drop_na() %>%
  mutate(timepoint1 = `62_DMNT1i_T1`- `62_Untreated`,
         timepoint2 = `62_DMNT1i_T2`- `62_Untreated`,
         timepoint3 = `62_DMNT1i_T3`- `62_Untreated`,
         timepoint4 = `62_DMNT1i_T4`- `62_Untreated`) 

diff_global$diff <- do.call(pmax, diff_global[,c("timepoint1", "timepoint2","timepoint3", "timepoint4")])

diff_global <- diff_global %>%
  group_by(Relation_to_UCSC_CpG_Island) %>%
  summarise(changed = sum(diff >=0.1), unchanged = sum(diff < 0.1)) %>%
  ungroup() 


diff_global %>% 
  mutate(Relation_to_UCSC_CpG_Island = if_else(Relation_to_UCSC_CpG_Island == "Others", "Others", "NonOthers"))%>%
  group_by(Relation_to_UCSC_CpG_Island) %>%
  summarise(changed_sum = sum(changed), unchanged_sum = sum(unchanged)) %>%
  column_to_rownames("Relation_to_UCSC_CpG_Island") %>%
fisher.test(., alternative = "greater")
```
# changes in Promoter CpG
# inspired by "DNA Hypermethylation Encroachment at CpG Island Borders in Cancer Is Predisposed by H3K4 Monomethylation Patterns"
```{r}
scatter_promoter_island_plot <- global %>%
  filter(Relation_to_UCSC_CpG_Island == "Island", str_detect(GencodeV41_Group, "TSS")) %>%
  pivot_longer(cols = all_of(timeseries), names_to = "cell_line", values_to = "beta") %>%
    group_by(UCSC_CpG_Islands_Name, cell_line) %>%
  summarise(avg_beta = mean(beta)) %>%
  ungroup() %>%
  pivot_wider(names_from = cell_line, values_from = avg_beta) %>%
  pivot_longer(cols = all_of(contains("OVCAR")), names_to = "timepoint", values_to = "avg_beta") %>%
  group_by(timepoint) %>%
  group_map(~ ggplot(.x, aes(x = `62_Untreated`, y = avg_beta))+
              geom_bin2d(bins =200)+
              stat_cor(method = "pearson")+
              scale_fill_gradient(name = "count",trans = "log2", breaks = c(1,4,16,64,512))+
              theme_bw()+
              ggtitle(paste0(unique(.y$timepoint)," vs baseline"))+
              ylim(c(0,1)), .keep =T)

sapply(seq(1,length(scatter_promoter_island_plot)), function(x) ggsave(plot = scatter_promoter_island_plot[[x]], paste0("plots/scatter_promoter_island_comparison_",as.character(x),".pdf")))


```
Going back to Skortsova's paper, they further cluster Islands for downstream analysis
They used kmean
but it is always good to check for data structure
```{r clustering CpG island}
library(uwot)
#reduce dimension
prin_comp <- prcomp(as.matrix(unique(global[which(global$Relation_to_UCSC_CpG_Island == "Island"),timeseries])))
plot(cumsum(prin_comp$sdev^2/sum(prin_comp$sdev^2))) #cumulative explained variance
pc.use = 2
trunc <- prin_comp$x[,1:pc.use] %*% t(prin_comp $rotation[,1:pc.use])

umap_projection <-umap(trunc, n_neighbors = 10, learning_rate = 0.5, init ="random")
rownames(umap_projection) <- unlist(unique(global[which(global$Relation_to_UCSC_CpG_Island == "Island"),"Name"]))
umap_projection %>%
  as.data.frame() %>%
  ggplot(aes( x = V1, y = V2))+
  geom_point()


```
HAHAHAHA it is a perfect sphere!!
lets do kmean clustering then
```{r}
#finding optimal cluster
kmean_withinss <- function(rescale_df, k) {
  df = data.frame(cluster = seq(1, k), withinss = rep(0,k))
  for (i in seq(1, k)){
    cluster <- kmeans(rescale_df, i)
    df[i, "withinss"] = cluster$tot.withinss
    
  } 
  return(df)
}
ggplot(data = kmean_withinss(unique(global[which(global$Relation_to_UCSC_CpG_Island == "Island"),timeseries]), 10), aes(x = cluster, y = withinss))+
  geom_line()
#these is no cluster!
```

# heatmap on changes of beta value on binned island
```{r}
island <- global %>%
  ungroup() %>%
  mutate(timepoint1 = `62GSK5_FB_1`- `62_parent`,
         timepoint2 = `62GSK5_FB_2`- `62_parent`,
         timepoint3 = `62GSK5_FB_3`- `62_parent`,
         timepoint4 = `62GSK5_FB_4`- `62_parent`,
         OVCAR8 = KF5_G10 - KF5_DMSO) %>%
  filter(str_detect(Relation_to_UCSC_CpG_Island, "Island")) %>%
  dplyr::select(starts_with("timepoint"),OVCAR8, Name, UCSC_CpG_Islands_Name, MAPINFO) %>%
  distinct() %>%
  drop_na()


heatmap_mat <- island %>%
  mutate(chr = sapply(UCSC_CpG_Islands_Name, function(x) unlist(strsplit(x, split = ":"))[1]),
         position = sapply(UCSC_CpG_Islands_Name, function(x) unlist(strsplit(x, split = ":"))[2])) %>%
  separate(position, into = c("start", "end"), sep = "-") %>%
  mutate(start = as.numeric(start), end = as.numeric(end),
         island_width  = end - start, bin_width = island_width /3,
         assigned_bin = ceiling((MAPINFO - start)/bin_width)) %>%
  pivot_longer(cols = c("timepoint1", "timepoint2", "timepoint3", "timepoint4","OVCAR8"), names_to = "timepoint", values_to = "beta") %>%
  group_by(UCSC_CpG_Islands_Name, assigned_bin, timepoint) %>%
  summarise(methylation = mean(beta)) %>%
  pivot_wider(names_from = assigned_bin, values_from = methylation) 

order = heatmap_mat %>%
  group_by(UCSC_CpG_Islands_Name) %>%
  summarise(total = sum(`1`, na.rm = T) + sum(`3`, na.rm = T) + sum(`3`, na.rm = T)) %>%
  arrange(desc(total))

library(circlize)
col_fun = colorRamp2(c(-1, 0, 1), c("blue", "white", "red"))

time1 = ComplexHeatmap::Heatmap((heatmap_mat[which(heatmap_mat$timepoint == "timepoint1"),] %>%
           column_to_rownames("UCSC_CpG_Islands_Name") %>%
           dplyr::select(as.character(seq(1,3))) %>%
                           as.matrix())[order$UCSC_CpG_Islands_Name,],cluster_columns = F, cluster_rows = F, show_row_names = F, col = col_fun)


time2 =ComplexHeatmap::Heatmap((heatmap_mat[which(heatmap_mat$timepoint == "timepoint2"),] %>%
           column_to_rownames("UCSC_CpG_Islands_Name") %>%
           dplyr::select(as.character(seq(1,3)))%>%
                           as.matrix())[order$UCSC_CpG_Islands_Name,],cluster_columns = F, cluster_rows = F, show_row_names = F, col = col_fun, show_heatmap_legend = F)

time3 =ComplexHeatmap::Heatmap((heatmap_mat[which(heatmap_mat$timepoint == "timepoint3"),] %>%
           column_to_rownames("UCSC_CpG_Islands_Name") %>%
           dplyr::select(as.character(seq(1,3)))%>%
                           as.matrix())[order$UCSC_CpG_Islands_Name,],cluster_columns = F, cluster_rows = F, show_row_names = F, col = col_fun, show_heatmap_legend = F)

time4 =ComplexHeatmap::Heatmap((heatmap_mat[which(heatmap_mat$timepoint == "timepoint4"),] %>%
           column_to_rownames("UCSC_CpG_Islands_Name") %>%
           dplyr::select(as.character(seq(1,3)))%>%
                           as.matrix())[order$UCSC_CpG_Islands_Name,],cluster_columns = F, cluster_rows = F, show_row_names = F, col = col_fun, show_heatmap_legend = F)

OVCAR8 = ComplexHeatmap::Heatmap((heatmap_mat[which(heatmap_mat$timepoint == "OVCAR8"),] %>%
           column_to_rownames("UCSC_CpG_Islands_Name") %>%
           dplyr::select(as.character(seq(1,3)))%>%
                           as.matrix())[order$UCSC_CpG_Islands_Name,],cluster_columns = F, cluster_rows = F, show_row_names = F, col = col_fun, show_heatmap_legend = F)
pdf("plots/island_timepoints.pdf", width = 10)
draw(time1+time2+time3+time4+OVCAR8)
dev.off()
```
#collapsed region of island shore and shelves 
```{r}
heatmap_mat  <- 
  global %>%
  ungroup() %>%
  filter(!is.na(Relation_to_UCSC_CpG_Island), Relation_to_UCSC_CpG_Island != "") %>%
  dplyr::select(starts_with("62") |starts_with("OVCAR8"),Name, UCSC_CpG_Islands_Name, MAPINFO, Relation_to_UCSC_CpG_Island) %>%
  distinct() %>%
  mutate(chr = sapply(UCSC_CpG_Islands_Name, function(x) unlist(strsplit(x, split = ":"))[1]),
         position = sapply(UCSC_CpG_Islands_Name, function(x) unlist(strsplit(x, split = ":"))[2])) %>%
  separate(position, into = c("start", "end"), sep = "-") %>%
  mutate(start = as.numeric(start), end = as.numeric(end),
         island_width  = end - start, bin_width = island_width /10,
         assigned_bin = case_when(Relation_to_UCSC_CpG_Island == "Island" ~ ceiling((MAPINFO - start)/bin_width),
                                  str_detect(Relation_to_UCSC_CpG_Island, "^S_") ~ ceiling((MAPINFO - end)/200) + 10,
                                  str_detect(Relation_to_UCSC_CpG_Island, "^N_")~ ceiling((MAPINFO - start)/200))) %>%
  pivot_longer(cols = all_of(timeseries), names_to = "timepoint", values_to = "beta") %>%
  group_by(UCSC_CpG_Islands_Name, assigned_bin, timepoint, Relation_to_UCSC_CpG_Island) %>%
  summarise(methylation = mean(beta)) %>%
  pivot_wider(names_from = assigned_bin, values_from = methylation) 

heatmap_mat %>%
  gather(key = "bin", value = "average_beta", -c("UCSC_CpG_Islands_Name","timepoint", "Relation_to_UCSC_CpG_Island") ) %>%
  filter( bin != "NA", !is.na(average_beta)) %>%
  mutate(bin = as.numeric(bin)) %>%
  group_by(bin, timepoint) %>%
  summarise(avg_methylation = mean(average_beta) * 100) %>%
  ungroup() %>%
  ggplot(aes(x = bin, y = avg_methylation, group = timepoint, color = timepoint))+
  geom_line()+
  scale_color_manual(values =timeseries_col, limits = force)+
  theme_bw()
ggsave("plots/binned_location.pdf", width = 10)


```
#heatmap for island clustering
```{r}
#TS1500
heatmap_mat <- global %>%
  ungroup() %>%
  filter( Relation_to_UCSC_CpG_Island =="Island", str_detect(GencodeV41_Group, "TSS")) %>%
  dplyr::select(starts_with("62"),UCSC_CpG_Islands_Name) %>%
  pivot_longer(cols = starts_with("62"), values_to = "beta", names_to = "cell_line") %>%
  unique() %>%
  group_by(cell_line, UCSC_CpG_Islands_Name) %>%
  summarise(avg_methylation = mean(beta)) %>%
  pivot_wider(names_from = cell_line, values_from = avg_methylation) %>%
  column_to_rownames("UCSC_CpG_Islands_Name")

write.csv(heatmap_mat, "tss1500.csv", quote = F)

CpG_clusters <- as.data.frame(fread("tss1500_kmean.csv")) %>%
  mutate(x = as.character(x)) %>%
  dplyr::rename(CpG = x) %>%
  column_to_rownames("V1")

CpG_clusters %>%
  group_by(CpG) %>%
  summarise(n=n())
ra = rowAnnotation(df = CpG_clusters)
pdf("plots/TS1500_heatmap_clustering.pdf")
Heatmap(heatmap_mat, show_row_names = F, right_annotation = ra)
dev.off()

#TS200
# heatmap_mat <- global %>%
#   ungroup() %>%
#   filter( Relation_to_UCSC_CpG_Island =="Island", str_detect(GencodeV41_Group, "TSS200")) %>%
#   dplyr::select(starts_with("62"),UCSC_CpG_Islands_Name) %>%
#   pivot_longer(cols = starts_with("62"), values_to = "beta", names_to = "cell_line") %>%
#   unique() %>%
#   group_by(cell_line, UCSC_CpG_Islands_Name) %>%
#   summarise(avg_methylation = mean(beta)) %>%
#   pivot_wider(names_from = cell_line, values_from = avg_methylation) %>%
#   column_to_rownames("UCSC_CpG_Islands_Name")
# 
# write.csv(heatmap_mat, "tss200.csv", quote = F)
# CpG_clusters <- as.data.frame(fread("tss200_kmean.csv")) %>%
#   mutate(x = as.character(x)) %>%
#   dplyr::rename(CpG = x) %>%
#   column_to_rownames("V1")
# 
# CpG_clusters %>%
#   group_by(CpG) %>%
#   summarise(n=n())
# ra = rowAnnotation(df = CpG_clusters)
# pdf("plots/TS200_heatmap_clustering.pdf")
# Heatmap(heatmap_mat, show_row_names = F, right_annotation = ra)
# dev.off()

```

#visualise them on a karyoplot may help with their location?
```{r plot karyoplot}
library("karyoploteR")

changedCpGgrange <- makeGRangesFromDataFrame(CpG_clusters %>%
                                               rownames_to_column("name") %>%
                                               filter(CpG %in% c("3", "2")) %>%
                                               mutate(CpG = if_else(CpG == "3", "grey", "green")) %>%
                                               separate(name,into = c("CHR", "start", "end")), keep.extra.columns = T, ignore.strand = T, start.field = "start", end.field = "end")
pdf("plots/genomic_loc_changed_CpG_with_treatment.pdf", height = 6, width = 5)
kp <- plotKaryotype(plot.type = 2, chromosomes = paste0("chr",seq(1:22)))
kpPoints(kp,data = changedCpGgrange, y =1, col = changedCpGgrange@elementMetadata@listData$CpG, cex = 0.6)
kpPlotDensity(kp,data = changedCpGgrange, data.panel = 2)

dev.off()
```
```{r trend of change}
global %>%
  dplyr::select(Name, starts_with("62"),CHR, MAPINFO, UCSC_CpG_Islands_Name, Relation_to_UCSC_CpG_Island) %>%
  left_join(CpG_clusters %>%
              rownames_to_column("UCSC_CpG_Islands_Name"))%>%
  filter(CpG == "1") %>%
  pivot_longer(all_of(starts_with("62")), names_to = "cell_line", values_to = "beta") %>%
  filter(UCSC_CpG_Islands_Name == "chr19:1591999-1593096") %>%
  ggplot(aes(x = MAPINFO, y = beta, color = cell_line))+
  geom_line()+
  facet_wrap(~UCSC_CpG_Islands_Name)
```
#enrichment
```{r}
#cluster2
gene_cluster2 <- annotation %>%
  filter(UCSC_CpG_Islands_Name %in% rownames(CpG_clusters)[which(CpG_clusters$CpG == "2")]) %>%
 pull(GencodeV41_Name)

gene_cluster2 <-unique(unlist(str_split(paste(gene_cluster2[str_detect(gene_cluster2,"^ENSG")], collapse = ";"), pattern = ";")))

gene_cluster2 <- gene_cluster2[str_detect(gene_cluster2,"^ENSG")]

gene_cluster2 <- unlist(lapply(gene_cluster2, function(x) unlist(strsplit(x, "\\."))[1]))

paste(gene_cluster2, collapse = " ")


# gene_cluster3 <- annotation %>%
  filter(UCSC_CpG_Islands_Name %in% rownames(CpG_clusters)[which(CpG_clusters$CpG == "3")]) %>%
 pull(GencodeV41_Name)

gene_cluster3 <-unique(unlist(str_split(paste(gene_cluster3[str_detect(gene_cluster3,"^ENSG")], collapse = ";"), pattern = ";")))

gene_cluster3 <- gene_cluster3[str_detect(gene_cluster3,"^ENSG")]

gene_cluster3 <- unlist(lapply(gene_cluster3, function(x) unlist(strsplit(x, "\\."))[1]))

paste(gene_cluster3, collapse = " ")


```
#location of the common differences TSS overlapped ISLAND
```{r where are the difference sits}
loc_global <- global %>%
  filter(str_detect(Relation_to_UCSC_CpG_Island, "Island"),str_detect(GencodeV41_Group, "TSS")) %>%
  drop_na() %>%
  mutate(timepoint1 = `62_DMNT1i_T1`- `62_Untreated`,
         timepoint2 = `62_DMNT1i_T2`- `62_Untreated`,
         timepoint3 = `62_DMNT1i_T3`- `62_Untreated`,
         timepoint4 = `62_DMNT1i_T4`- `62_Untreated`,
         OVCAR8 = OVCAR8_DMNT1i - OVCAR8_Untreated) 

loc_global$diff <- do.call(pmax, loc_global[,c("timepoint1", "timepoint2","timepoint3", "timepoint4", "OVCAR8")])

loc_global <- loc_global %>%
  filter(abs(diff ) >=0.1) %>%
  group_by(Name) %>%
  filter(sum(timepoint1 >0, timepoint2 >0, timepoint3 >0,timepoint4 >0,OVCAR8 >0)==0)


library(TSclust)
mat <- loc_global %>%
  dplyr::select(Name, starts_with("62")) %>%
  distinct() %>%
  column_to_rownames("Name") %>%
  as.matrix()

mat_dist <- diss(mat, "EUCL")

# optimising with silhouette and elbow plot
ggplot(data = kmean_withinss(mat_dist,10), aes(x = cluster, y = withinss))+
  geom_line()+
  geom_point()


silhouette_score <- function(k){
  km <- kmeans(mat_dist, centers = k)
  ss <- silhouette(km$cluster, mat_dist)
  mean(ss[, 3])
}
k <- 2:10
avg_sil <- sapply(k, silhouette_score)
plot(k, type='b', avg_sil, xlab='Number of clusters', ylab='Average Silhouette Scores', frame=FALSE)

# clustering
cluster <- kmeans(mat_dist, 2, nstart = 10)
plot(silhouette(cluster$cluster, mat_dist), col=1:2, border=NA)



data.frame(mat)%>%
   mutate(cluster = cluster$cluster) %>%
  rownames_to_column("CpG") %>%
  gather(key = "timepoint", value = "beta", -c(cluster, CpG)) %>%
  mutate(timepoint = case_when(str_detect(timepoint, "FB_1") ~ "timepoint1",
                                str_detect(timepoint, "FB_2") ~ "timepoint2",
                                str_detect(timepoint, "FB_3") ~ "timepoint3",
                                str_detect(timepoint, "FB_4") ~ "timepoint4",
                                TRUE  ~ "baseline"),
         timepoint = factor(timepoint, levels = c("baseline", "timepoint1", "timepoint2", "timepoint3", "timepoint4")),
         cluster = as.character(cluster)) %>%
  ggplot(aes(x = timepoint, y = beta, color = cluster, group = CpG))+
  geom_line(alpha = 0.6)+
  facet_wrap(~cluster)+
   theme_bw()+
  theme(axis.text.x =element_text(angle = 90, vjust = 0.5))+
  ggtitle("timeseries clustering for Island CpG probes (TSS 1500)")


data.frame(mat)%>%
   mutate(cluster = cluster$cluster)  %>%
  group_by(cluster) %>%
  summarise(n=n())


data.frame(mat)%>%
   mutate(cluster = cluster$cluster)  %>%
  rownames_to_column("Name") %>%
  dplyr::select(Name, cluster) %>%
  left_join(annotation %>%
              dplyr::select(Name,UCSC_RefGene_Name)) %>%
  filter(UCSC_RefGene_Name != "") %>%
  separate_rows("UCSC_RefGene_Name", sep = ";") %>%
  distinct() %>%
  group_by(UCSC_RefGene_Name) %>%
  summarise(cluster_2_proportion = sum(cluster == 2)/n(), coverage = n_distinct(Name)) %>%
  ungroup() %>%
  filter(coverage >=3, cluster_2_proportion>=0.75) -> cluster_enrichment
  ggplot(aes(y = cluster_2_proportion, x = coverage))+
  geom_jitter()
  
  paste(cluster_enrichment$UCSC_RefGene_Name, collapse= " ")
```

```{r}
library("karyoploteR")
library("GenomicRanges")

CpG_consistent = makeGRangesFromDataFrame(loc_global %>%
                                                     dplyr::select(CHR, Start = MAPINFO, End = MAPINFO, CpG = Name, `62_parent`, `62GSK5_FB_1`, `62GSK5_FB_2`,
                                                                   `62GSK5_FB_3`, `62GSK5_FB_4`, `KF5_G10`, `KF5_DMSO`),keep.extra.columns = T)
pdf("plots/karyoplot_consistent_position_62.pdf")
kp <- plotKaryotype(plot.type = 2, chromosomes = paste0("chr",seq(1:22)))
kpPoints(kp,data = CpG_consistent, y = CpG_consistent@elementMetadata@listData$`62_parent`, col = timeseries_col["62_parent"], cex = 0.4)
kpPoints(kp,data = CpG_consistent, y = CpG_consistent@elementMetadata@listData$`62GSK5_FB_1`, col = timeseries_col["62GSK5_FB_1"], cex = 0.4)
kpPoints(kp,data = CpG_consistent, y = CpG_consistent@elementMetadata@listData$`62GSK5_FB_2`, col = timeseries_col["62GSK5_FB_2"], cex = 0.4)
kpPoints(kp,data = CpG_consistent, y = CpG_consistent@elementMetadata@listData$`62GSK5_FB_3`, col = timeseries_col["62GSK5_FB_3"], cex = 0.4)
kpPoints(kp,data = CpG_consistent, y = CpG_consistent@elementMetadata@listData$`62GSK5_FB_4`, col = timeseries_col["62GSK5_FB_4"], cex = 0.4)
dev.off()

pdf("plots/karyoplot_consistent_position_OCVAR8.pdf")
kp <- plotKaryotype(plot.type = 2, chromosomes = paste0("chr",seq(1:22)))
kpPoints(kp,data = CpG_consistent, y = CpG_consistent@elementMetadata@listData$`KF5_G10`, col = timeseries_col["KF5_G10"], cex = 0.4)
kpPoints(kp,data = CpG_consistent, y = CpG_consistent@elementMetadata@listData$`KF5_DMSO`, col = timeseries_col["KF5_DMSO"], cex = 0.4)
dev.off()
```
```{r directional change}
directionCpG <- changed_CpG %>%
  dplyr::select(-starts_with("62")) %>%
  rownames_to_column("Name") %>%
  gather(key = "comparison", value = "delta_beta", -"Name") %>%
  left_join(annotation%>%
              as.data.frame() %>%
              dplyr::select(annotation_rows) %>%
              filter(Name %in% rownames(changed_CpG)), by = "Name")  %>%
  distinct()%>%  
  group_by(Name) %>%
  summarise(`Methylated to baseline` = sum(delta_beta >0), `Demethylated to baseline` = -sum(delta_beta < 0 ), Relation_to_UCSC_CpG_Island, Regulatory_Feature_Group)

directionCpG %>%
  ungroup()%>%
  mutate(change = case_when(`Methylated to baseline` ==0 & `Demethylated to baseline` != 0 ~ "Demeth/Transient Demeth",
                            `Methylated to baseline` !=0 & `Demethylated to baseline` == 0 ~ "Meth/Transient Meth",
                            `Methylated to baseline` !=0 & `Demethylated to baseline` != 0 ~ "?variable Meth/Demeth"),
         transient = case_when(`Methylated to baseline` ==4 |`Demethylated to baseline` == -4 ~ "No",
                               TRUE ~"Yes")) %>%
  group_by(change, transient) %>%
  summarise(n=n()) %>%
  ungroup() %>%
  mutate(percent = n/sum(n))

#manually inspect sites with methylation and demethylation
#these probes are likely to be variable methylation sites. I will remove them
# 275 sites
#regulatory component
directionCpG %>%
  # filter(str_detect(pattern = "Island", string = Relation_to_UCSC_CpG_Island)) %>%
  ungroup() %>%
  group_by(`Methylated to baseline` ,`Demethylated to baseline`, Regulatory_Feature_Group) %>%
  summarise(n=n()) %>%
  ungroup() %>%
  mutate(change_direction = paste(`Methylated to baseline` ,`Demethylated to baseline`, sep = ";"),
         change_direction = factor(change_direction, levels = c("0;-4", "0;-3", "0;-2", "0;-1", "1;-3", "1;-2", "1;-1", "2;-1", "3;-1",  "1;0","2;0", "3;0", "4;0"))) %>%
  ggplot(aes(x = change_direction, y = n, fill = Regulatory_Feature_Group)) +
  geom_bar(stat= "identity", position = "dodge", color = "black")+
  scale_y_continuous(trans = log2_trans(), breaks = trans_breaks("log10", function(x) 10^x),
    labels = trans_format("log10", math_format(10^.x)))+
  scale_fill_brewer(palette = "Set3")+
  facet_wrap(~Regulatory_Feature_Group)+
  theme_bw()
  
ggsave("plots/relative_change_regulatory_element.pdf", height = 10, width = 15) 



directionCpG %>%
  # filter(!(`Methylated to baseline` != 0 & `Demethylated to baseline` != 0)) %>%
  ungroup() %>%
  group_by(`Methylated to baseline` ,`Demethylated to baseline`, Relation_to_UCSC_CpG_Island) %>%
  summarise(n=n()) %>%
  ungroup() %>%
  mutate(change_direction = paste(`Methylated to baseline` ,`Demethylated to baseline`, sep = ";"),
         change_direction = factor(change_direction, levels = c("0;-4", "0;-3", "0;-2", "0;-1", "1;-3", "1;-2", "1;-1", "2;-1", "3;-1",  "1;0","2;0", "3;0", "4;0")),
         Relation_to_UCSC_CpG_Island = sapply(Relation_to_UCSC_CpG_Island, function(x) paste(unique(unlist(strsplit(gsub("N_|S_", "", x), split = ";"))), collapse = ";"))) %>%
  ggplot(aes(x = change_direction, y = n, fill = Relation_to_UCSC_CpG_Island)) +
  geom_bar(stat= "identity", position = "dodge", color = "black")+
  scale_y_continuous(trans = log2_trans(), breaks = trans_breaks("log10", function(x) 10^x),
    labels = trans_format("log10", math_format(10^.x)))+
  scale_fill_brewer(palette = "Set3")+
  facet_wrap(~Relation_to_UCSC_CpG_Island)+
  theme_bw()
  
  
```
```{r}
changed_CpG_df <- changed_CpG %>%
  dplyr::select(-starts_with("bl_")) %>%
  rownames_to_column("Name") %>%
  gather(key = "cell_line", value = "beta", -"Name") %>%
  left_join(annotation%>%
              as.data.frame() %>%
              dplyr::select(annotation_rows) %>%
              filter(Name %in% rownames(changed_CpG)) %>%
              distinct(), by = "Name") %>%
  filter(!is.na(Name), !is.na(CHR), !is.na(MAPINFO))

changed_CpG_df %>%
  filter(str_detect(Regulatory_Feature_Group, "Promoter"), !CHR =="chrY") %>%
  ggplot(aes(x = MAPINFO, y = beta, color = cell_line, group = cell_line))+
  geom_line(size = 0.4)+
  facet_grid(rows = vars(CHR), scales = "free_x", space = "free")+
  scale_color_manual(values= timeseries_col)
ggsave("plots/promoter_cpgisland_beta.pdf", width = 10, height= 20 )



```









```{r}
library("GenomicRanges")
changed_CpG_df <- changed_CpG %>%
  dplyr::select(-starts_with("bl_")) %>%
  rownames_to_column("Name") %>%
  gather(key = "cell_line", value = "beta", -"Name") %>%
  left_join(annotation%>%
              as.data.frame() %>%
              dplyr::select(annotation_rows) %>%
              filter(Name %in% rownames(changed_CpG)), by = "Name") %>%
  filter(!is.na(Name), !is.na(CHR), !is.na(MAPINFO))

```

karyoplot are too crowded for the detailed difference
```{r zoom in difference}
changed_CpG_df %>%
  ggplot(aes(y = beta, x = Name, color = cell_line))+
geom_point()+
  scale_color_manual(values = timeseries_col)+
  facet_wrap(~Relation_to_Island, scales = "free")+
  theme_bw()+
  theme(legend.position = "bottom", axis.text.x = element_blank(), axis.ticks.x = element_blank())+
  ggtitle("Beta value at changed CpG probes")

ggsave("plots/absolute_beta_value_at_changedCpG.pdf", height = 6, width = 10)

timeseries_relative_col = c("bl_1" = "#d9ed92",  "bl_2" = "#76c893", "bl_3" = "#168aad", "bl_4" = "#1e6091")
changed_CpG %>%
  dplyr::select(-starts_with("62")) %>%
  rownames_to_column("Name") %>%
  gather(key = "comparison", value = "delta_beta", -"Name") %>%
  left_join(annotation%>%
              as.data.frame() %>%
              dplyr::select(annotation_rows) %>%
              filter(Name %in% rownames(changed_CpG)), by = "Name") %>%
  filter(!is.na(chr), !is.na(pos)) %>%
  ggplot(aes(y = delta_beta, x = Name, color = comparison))+
geom_jitter()+
  scale_color_manual(values = timeseries_relative_col)+
  facet_wrap(~Relation_to_Island, scales = "free")+
  geom_hline(yintercept = 0)+
  theme_bw()+
  theme(legend.position = "bottom", axis.text.x = element_blank(), axis.ticks.x = element_blank())+
  ggtitle("Relative Beta value change at changed CpG probes")
 ggsave("plots/relative_beta_value_at_changedCpG.pdf", height = 6, width = 10) 
  
```

now that I noticed one thing I did not consider. the direction of change.
The hypothesis would be GSK cause global demethylation
so we should split changes to demethylation to untreated or methylated to treated 

out of 208 CpG probes 78 CpG demethylated from the GSK treatment , 131 CpG methylated from the GSK treatment

```{r}
#dmp between treated and untreated (not the best approach)
# dmpFinder(norm_beta[,c("62GSK5_FB_1", "62GSK5_FB_2", "62GSK5_FB_3", "62GSK5_FB_4", "62_parent")], pheno = c("treated", "treated", "treated", "treated", "control"), qCutoff = 0.05)


```
